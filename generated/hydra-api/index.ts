/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Ory Hydra API
 * Documentation for all of Ory Hydra's APIs.

 */
import type {
  AcceptDeviceUserCodeRequest,
  AcceptOAuth2ConsentRequest,
  AcceptOAuth2ConsentRequestParams,
  AcceptOAuth2LoginRequest,
  AcceptOAuth2LoginRequestParams,
  AcceptOAuth2LogoutRequestParams,
  AcceptUserCodeRequestParams,
  CreateJsonWebKeySet,
  CreateVerifiableCredentialRequestBody,
  DeleteOAuth2TokenParams,
  DeviceAuthorization,
  EmptyResponseResponse,
  ErrorOAuth2,
  GetOAuth2ConsentRequestParams,
  GetOAuth2LoginRequestParams,
  GetOAuth2LogoutRequestParams,
  GetVersion200,
  HealthStatus,
  IntrospectOAuth2TokenBody,
  IntrospectedOAuth2Token,
  IsReady200,
  JsonPatchDocument,
  JsonWebKey,
  JsonWebKeySet,
  ListOAuth2ClientsParams,
  ListOAuth2ClientsResponse,
  ListOAuth2ConsentSessionsParams,
  ListTrustedOAuth2JwtGrantIssuersParams,
  OAuth2Client,
  OAuth2ClientTokenLifespans,
  OAuth2ConsentRequest,
  OAuth2ConsentSessions,
  OAuth2LoginRequest,
  OAuth2LogoutRequest,
  OAuth2RedirectTo,
  OAuth2TokenExchange,
  Oauth2TokenExchangeBody,
  OidcConfiguration,
  OidcUserInfo,
  RejectOAuth2ConsentRequestParams,
  RejectOAuth2LoginRequestParams,
  RejectOAuth2LogoutRequestParams,
  RejectOAuth2Request,
  RevokeOAuth2ConsentSessionsParams,
  RevokeOAuth2LoginSessionsParams,
  RevokeOAuth2TokenBody,
  TrustOAuth2JwtGrantIssuer,
  TrustedOAuth2JwtGrantIssuer,
  TrustedOAuth2JwtGrantIssuers,
  VerifiableCredentialResponse
} from './models';

import { hydraMutator } from '../../lib/api/hydra-client';
export const getOryHydraAPI = () => {
/**
 * This endpoint returns JSON Web Keys required to verifying OpenID Connect ID Tokens and,
if enabled, OAuth 2.0 JWT Access Tokens. This endpoint can be used with client libraries like
[node-jwks-rsa](https://github.com/auth0/node-jwks-rsa) among others.

Adding custom keys requires first creating a keyset via the createJsonWebKeySet operation,
and then configuring the webfinger.jwks.broadcast_keys configuration value to include the keyset name.
 * @summary Discover Well-Known JSON Web Keys
 */
const discoverJsonWebKeys = (
    
 ) => {
      return hydraMutator<JsonWebKeySet>(
      {url: `/.well-known/jwks.json`, method: 'GET'
    },
      );
    }
  
/**
 * A mechanism for an OpenID Connect Relying Party to discover the End-User's OpenID Provider and obtain information needed to interact with it, including its OAuth 2.0 endpoint locations.

Popular libraries for OpenID Connect clients include oidc-client-js (JavaScript), go-oidc (Golang), and others.
For a full list of clients go here: https://openid.net/developers/certified/
 * @summary OpenID Connect Discovery
 */
const discoverOidcConfiguration = (
    
 ) => {
      return hydraMutator<OidcConfiguration>(
      {url: `/.well-known/openid-configuration`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint lists all clients in the database, and never returns client secrets.
As a default it lists the first 100 clients.
 * @summary List OAuth 2.0 Clients
 */
const listOAuth2Clients = (
    params?: ListOAuth2ClientsParams,
 ) => {
      return hydraMutator<ListOAuth2ClientsResponse>(
      {url: `/admin/clients`, method: 'GET',
        params
    },
      );
    }
  
/**
 * Create a new OAuth 2.0 client. If you pass `client_secret` the secret is used, otherwise a random secret
is generated. The secret is echoed in the response. It is not possible to retrieve it later on.
 * @summary Create OAuth 2.0 Client
 */
const createOAuth2Client = (
    oAuth2Client: OAuth2Client,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/admin/clients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: oAuth2Client
    },
      );
    }
  
/**
 * Delete an existing OAuth 2.0 Client by its ID.

OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.

Make sure that this endpoint is well protected and only callable by first-party components.
 * @summary Delete OAuth 2.0 Client
 */
const deleteOAuth2Client = (
    id: string,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/clients/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.

OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 * @summary Get an OAuth 2.0 Client
 */
const getOAuth2Client = (
    id: string,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/admin/clients/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * Patch an existing OAuth 2.0 Client using JSON Patch. If you pass `client_secret`
the secret will be updated and returned via the API. This is the
only time you will be able to retrieve the client secret, so write it down and keep it safe.

OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 * @summary Patch OAuth 2.0 Client
 */
const patchOAuth2Client = (
    id: string,
    jsonPatchDocument: JsonPatchDocument,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/admin/clients/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: jsonPatchDocument
    },
      );
    }
  
/**
 * Replaces an existing OAuth 2.0 Client with the payload you send. If you pass `client_secret` the secret is used,
otherwise the existing secret is used.

If set, the secret is echoed in the response. It is not possible to retrieve it later on.

OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 * @summary Set OAuth 2.0 Client
 */
const setOAuth2Client = (
    id: string,
    oAuth2Client: OAuth2Client,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/admin/clients/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: oAuth2Client
    },
      );
    }
  
/**
 * Set lifespans of different token types issued for this OAuth 2.0 client. Does not modify other fields.
 * @summary Set OAuth2 Client Token Lifespans
 */
const setOAuth2ClientLifespans = (
    id: string,
    oAuth2ClientTokenLifespans: OAuth2ClientTokenLifespans,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/admin/clients/${id}/lifespans`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: oAuth2ClientTokenLifespans
    },
      );
    }
  
/**
 * Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.

A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 * @summary Delete JSON Web Key Set
 */
const deleteJsonWebKeySet = (
    set: string,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/keys/${set}`, method: 'DELETE'
    },
      );
    }
  
/**
 * This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.

A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 * @summary Retrieve a JSON Web Key Set
 */
const getJsonWebKeySet = (
    set: string,
 ) => {
      return hydraMutator<JsonWebKeySet>(
      {url: `/admin/keys/${set}`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.

A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 * @summary Create JSON Web Key
 */
const createJsonWebKeySet = (
    set: string,
    createJsonWebKeySet: CreateJsonWebKeySet,
 ) => {
      return hydraMutator<JsonWebKeySet>(
      {url: `/admin/keys/${set}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createJsonWebKeySet
    },
      );
    }
  
/**
 * Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.

A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 * @summary Update a JSON Web Key Set
 */
const setJsonWebKeySet = (
    set: string,
    jsonWebKeySet: JsonWebKeySet,
 ) => {
      return hydraMutator<JsonWebKeySet>(
      {url: `/admin/keys/${set}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: jsonWebKeySet
    },
      );
    }
  
/**
 * Use this endpoint to delete a single JSON Web Key.

A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A
JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses
this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens),
and allows storing user-defined keys as well.
 * @summary Delete JSON Web Key
 */
const deleteJsonWebKey = (
    set: string,
    kid: string,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/keys/${set}/${kid}`, method: 'DELETE'
    },
      );
    }
  
/**
 * This endpoint returns a singular JSON Web Key contained in a set. It is identified by the set and the specific key ID (kid).
 * @summary Get JSON Web Key
 */
const getJsonWebKey = (
    set: string,
    kid: string,
 ) => {
      return hydraMutator<JsonWebKeySet>(
      {url: `/admin/keys/${set}/${kid}`, method: 'GET'
    },
      );
    }
  
/**
 * Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.

A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 * @summary Set JSON Web Key
 */
const setJsonWebKey = (
    set: string,
    kid: string,
    jsonWebKey: JsonWebKey,
 ) => {
      return hydraMutator<JsonWebKey>(
      {url: `/admin/keys/${set}/${kid}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: jsonWebKey
    },
      );
    }
  
/**
 * When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
to authenticate the subject and then tell Ory now about it. If the subject authenticated, he/she must now be asked if
the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject's behalf.

The consent challenge is appended to the consent provider's URL to which the subject's user-agent (browser) is redirected to. The consent
provider uses that challenge to fetch information on the OAuth2 request and then tells Ory if the subject accepted
or rejected the request.

The default consent provider is available via the Ory Managed Account Experience. To customize the consent provider, please
head over to the OAuth 2.0 documentation.
 * @summary Get OAuth 2.0 Consent Request
 */
const getOAuth2ConsentRequest = (
    params: GetOAuth2ConsentRequestParams,
 ) => {
      return hydraMutator<OAuth2ConsentRequest>(
      {url: `/admin/oauth2/auth/requests/consent`, method: 'GET',
        params
    },
      );
    }
  
/**
 * When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
to authenticate the subject and then tell Ory now about it. If the subject authenticated, he/she must now be asked if
the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject's behalf.

The consent challenge is appended to the consent provider's URL to which the subject's user-agent (browser) is redirected to. The consent
provider uses that challenge to fetch information on the OAuth2 request and then tells Ory if the subject accepted
or rejected the request.

This endpoint tells Ory that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf.
The consent provider includes additional information, such as session data for access and ID tokens, and if the
consent request should be used as basis for future requests.

The response contains a redirect URL which the consent provider should redirect the user-agent to.

The default consent provider is available via the Ory Managed Account Experience. To customize the consent provider, please
head over to the OAuth 2.0 documentation.
 * @summary Accept OAuth 2.0 Consent Request
 */
const acceptOAuth2ConsentRequest = (
    acceptOAuth2ConsentRequest: AcceptOAuth2ConsentRequest,
    params: AcceptOAuth2ConsentRequestParams,
 ) => {
      return hydraMutator<OAuth2RedirectTo>(
      {url: `/admin/oauth2/auth/requests/consent/accept`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: acceptOAuth2ConsentRequest,
        params
    },
      );
    }
  
/**
 * When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
to authenticate the subject and then tell Ory now about it. If the subject authenticated, he/she must now be asked if
the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject's behalf.

The consent challenge is appended to the consent provider's URL to which the subject's user-agent (browser) is redirected to. The consent
provider uses that challenge to fetch information on the OAuth2 request and then tells Ory if the subject accepted
or rejected the request.

This endpoint tells Ory that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf.
The consent provider must include a reason why the consent was not granted.

The response contains a redirect URL which the consent provider should redirect the user-agent to.

The default consent provider is available via the Ory Managed Account Experience. To customize the consent provider, please
head over to the OAuth 2.0 documentation.
 * @summary Reject OAuth 2.0 Consent Request
 */
const rejectOAuth2ConsentRequest = (
    rejectOAuth2Request: RejectOAuth2Request,
    params: RejectOAuth2ConsentRequestParams,
 ) => {
      return hydraMutator<OAuth2RedirectTo>(
      {url: `/admin/oauth2/auth/requests/consent/reject`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: rejectOAuth2Request,
        params
    },
      );
    }
  
/**
 * Accepts a device grant user_code request
 * @summary Accepts a device grant user_code request
 */
const acceptUserCodeRequest = (
    acceptDeviceUserCodeRequest: AcceptDeviceUserCodeRequest,
    params: AcceptUserCodeRequestParams,
 ) => {
      return hydraMutator<OAuth2RedirectTo>(
      {url: `/admin/oauth2/auth/requests/device/accept`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: acceptDeviceUserCodeRequest,
        params
    },
      );
    }
  
/**
 * When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
to authenticate the subject and then tell the Ory OAuth2 Service about it.

Per default, the login provider is Ory itself. You may use a different login provider which needs to be a web-app
you write and host, and it must be able to authenticate ("show the subject a login screen")
a subject (in OAuth2 the proper name for subject is "resource owner").

The authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login
provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
 * @summary Get OAuth 2.0 Login Request
 */
const getOAuth2LoginRequest = (
    params: GetOAuth2LoginRequestParams,
 ) => {
      return hydraMutator<OAuth2LoginRequest>(
      {url: `/admin/oauth2/auth/requests/login`, method: 'GET',
        params
    },
      );
    }
  
/**
 * When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
to authenticate the subject and then tell the Ory OAuth2 Service about it.

The authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login
provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.

This endpoint tells Ory that the subject has successfully authenticated and includes additional information such as
the subject's ID and if Ory should remember the subject's subject agent for future authentication attempts by setting
a cookie.

The response contains a redirect URL which the login provider should redirect the user-agent to.
 * @summary Accept OAuth 2.0 Login Request
 */
const acceptOAuth2LoginRequest = (
    acceptOAuth2LoginRequest: AcceptOAuth2LoginRequest,
    params: AcceptOAuth2LoginRequestParams,
 ) => {
      return hydraMutator<OAuth2RedirectTo>(
      {url: `/admin/oauth2/auth/requests/login/accept`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: acceptOAuth2LoginRequest,
        params
    },
      );
    }
  
/**
 * When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
to authenticate the subject and then tell the Ory OAuth2 Service about it.

The authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login
provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.

This endpoint tells Ory that the subject has not authenticated and includes a reason why the authentication
was denied.

The response contains a redirect URL which the login provider should redirect the user-agent to.
 * @summary Reject OAuth 2.0 Login Request
 */
const rejectOAuth2LoginRequest = (
    rejectOAuth2Request: RejectOAuth2Request,
    params: RejectOAuth2LoginRequestParams,
 ) => {
      return hydraMutator<OAuth2RedirectTo>(
      {url: `/admin/oauth2/auth/requests/login/reject`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: rejectOAuth2Request,
        params
    },
      );
    }
  
/**
 * Use this endpoint to fetch an Ory OAuth 2.0 logout request.
 * @summary Get OAuth 2.0 Session Logout Request
 */
const getOAuth2LogoutRequest = (
    params: GetOAuth2LogoutRequestParams,
 ) => {
      return hydraMutator<OAuth2LogoutRequest>(
      {url: `/admin/oauth2/auth/requests/logout`, method: 'GET',
        params
    },
      );
    }
  
/**
 * When a user or an application requests Ory OAuth 2.0 to remove the session state of a subject, this endpoint is used to confirm that logout request.

The response contains a redirect URL which the consent provider should redirect the user-agent to.
 * @summary Accept OAuth 2.0 Session Logout Request
 */
const acceptOAuth2LogoutRequest = (
    params: AcceptOAuth2LogoutRequestParams,
 ) => {
      return hydraMutator<OAuth2RedirectTo>(
      {url: `/admin/oauth2/auth/requests/logout/accept`, method: 'PUT',
        params
    },
      );
    }
  
/**
 * When a user or an application requests Ory OAuth 2.0 to remove the session state of a subject, this endpoint is used to deny that logout request.
No HTTP request body is required.

The response is empty as the logout provider has to chose what action to perform next.
 * @summary Reject OAuth 2.0 Session Logout Request
 */
const rejectOAuth2LogoutRequest = (
    params: RejectOAuth2LogoutRequestParams,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/oauth2/auth/requests/logout/reject`, method: 'PUT',
        params
    },
      );
    }
  
/**
 * This endpoint revokes a subject's granted consent sessions and invalidates all
associated OAuth 2.0 Access Tokens. You may also only revoke sessions for a specific OAuth 2.0 Client ID.
 * @summary Revoke OAuth 2.0 Consent Sessions of a Subject
 */
const revokeOAuth2ConsentSessions = (
    params?: RevokeOAuth2ConsentSessionsParams,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/oauth2/auth/sessions/consent`, method: 'DELETE',
        params
    },
      );
    }
  
/**
 * This endpoint lists all subject's granted consent sessions, including client and granted scope.
If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an
empty JSON array with status code 200 OK.
 * @summary List OAuth 2.0 Consent Sessions of a Subject
 */
const listOAuth2ConsentSessions = (
    params: ListOAuth2ConsentSessionsParams,
 ) => {
      return hydraMutator<OAuth2ConsentSessions>(
      {url: `/admin/oauth2/auth/sessions/consent`, method: 'GET',
        params
    },
      );
    }
  
/**
 * This endpoint invalidates authentication sessions. After revoking the authentication session(s), the subject
has to re-authenticate at the Ory OAuth2 Provider. This endpoint does not invalidate any tokens.

If you send the subject in a query param, all authentication sessions that belong to that subject are revoked.
No OpenID Connect Front- or Back-channel logout is performed in this case.

Alternatively, you can send a SessionID via `sid` query param, in which case, only the session that is connected
to that SessionID is revoked. OpenID Connect Back-channel logout is performed in this case.

When using Ory for the identity provider, the login provider will also invalidate the session cookie.
 * @summary Revokes OAuth 2.0 Login Sessions by either a Subject or a SessionID
 */
const revokeOAuth2LoginSessions = (
    params?: RevokeOAuth2LoginSessionsParams,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/oauth2/auth/sessions/login`, method: 'DELETE',
        params
    },
      );
    }
  
/**
 * The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token
is neither expired nor revoked. If a token is active, additional information on the token will be included. You can
set additional data for a token by setting `session.access_token` during the consent flow.
 * @summary Introspect OAuth2 Access and Refresh Tokens
 */
const introspectOAuth2Token = (
    introspectOAuth2TokenBody: IntrospectOAuth2TokenBody,
 ) => {const formUrlEncoded = new URLSearchParams();
if(introspectOAuth2TokenBody.scope !== undefined) {
 formUrlEncoded.append(`scope`, introspectOAuth2TokenBody.scope)
 }
formUrlEncoded.append(`token`, introspectOAuth2TokenBody.token)

      return hydraMutator<IntrospectedOAuth2Token>(
      {url: `/admin/oauth2/introspect`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded
    },
      );
    }
  
/**
 * This endpoint deletes OAuth2 access tokens issued to an OAuth 2.0 Client from the database.
 * @summary Delete OAuth 2.0 Access Tokens from specific OAuth 2.0 Client
 */
const deleteOAuth2Token = (
    params: DeleteOAuth2TokenParams,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/oauth2/tokens`, method: 'DELETE',
        params
    },
      );
    }
  
/**
 * Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
 * @summary List Trusted OAuth2 JWT Bearer Grant Type Issuers
 */
const listTrustedOAuth2JwtGrantIssuers = (
    params?: ListTrustedOAuth2JwtGrantIssuersParams,
 ) => {
      return hydraMutator<TrustedOAuth2JwtGrantIssuers>(
      {url: `/admin/trust/grants/jwt-bearer/issuers`, method: 'GET',
        params
    },
      );
    }
  
/**
 * Use this endpoint to establish a trust relationship for a JWT issuer
to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication
and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
 * @summary Trust OAuth2 JWT Bearer Grant Type Issuer
 */
const trustOAuth2JwtGrantIssuer = (
    trustOAuth2JwtGrantIssuer: TrustOAuth2JwtGrantIssuer,
 ) => {
      return hydraMutator<TrustedOAuth2JwtGrantIssuer>(
      {url: `/admin/trust/grants/jwt-bearer/issuers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: trustOAuth2JwtGrantIssuer
    },
      );
    }
  
/**
 * Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you
created the trust relationship.

Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile
for OAuth 2.0 Client Authentication and Authorization Grant.
 * @summary Delete Trusted OAuth2 JWT Bearer Grant Type Issuer
 */
const deleteTrustedOAuth2JwtGrantIssuer = (
    id: string,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/admin/trust/grants/jwt-bearer/issuers/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you
created the trust relationship.
 * @summary Get Trusted OAuth2 JWT Bearer Grant Type Issuer
 */
const getTrustedOAuth2JwtGrantIssuer = (
    id: string,
 ) => {
      return hydraMutator<TrustedOAuth2JwtGrantIssuer>(
      {url: `/admin/trust/grants/jwt-bearer/issuers/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint creates a verifiable credential that attests that the user
authenticated with the provided access token owns a certain public/private key
pair.

More information can be found at
https://openid.net/specs/openid-connect-userinfo-vc-1_0.html.
 * @summary Issues a Verifiable Credential
 */
const createVerifiableCredential = (
    createVerifiableCredentialRequestBody: CreateVerifiableCredentialRequestBody,
 ) => {
      return hydraMutator<VerifiableCredentialResponse>(
      {url: `/credentials`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createVerifiableCredentialRequestBody
    },
      );
    }
  
/**
 * This endpoint returns a HTTP 200 status code when Ory Hydra is accepting incoming
HTTP requests. This status does currently not include checks whether the database connection is working.

If the service supports TLS Edge Termination, this endpoint does not require the
`X-Forwarded-Proto` header to be set.

Be aware that if you are running multiple nodes of this service, the health status will never
refer to the cluster state, only to a single instance.
 * @summary Check HTTP Server Status
 */
const isAlive = (
    
 ) => {
      return hydraMutator<HealthStatus>(
      {url: `/health/alive`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint returns a HTTP 200 status code when Ory Hydra is up running and the environment dependencies (e.g.
the database) are responsive as well.

If the service supports TLS Edge Termination, this endpoint does not require the
`X-Forwarded-Proto` header to be set.

Be aware that if you are running multiple nodes of Ory Hydra, the health status will never
refer to the cluster state, only to a single instance.
 * @summary Check HTTP Server and Database Status
 */
const isReady = (
    
 ) => {
      return hydraMutator<IsReady200>(
      {url: `/health/ready`, method: 'GET'
    },
      );
    }
  
/**
 * Use open source libraries to perform OAuth 2.0 and OpenID Connect
available for any programming language. You can find a list of libraries at https://oauth.net/code/

This endpoint should not be used via the Ory SDK and is only included for technical reasons.
Instead, use one of the libraries linked above.
 * @summary OAuth 2.0 Authorize Endpoint
 */
const oAuth2Authorize = (
    
 ) => {
      return hydraMutator<ErrorOAuth2>(
      {url: `/oauth2/auth`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint is not documented here because you should never use your own implementation to perform OAuth2 flows.
OAuth2 is a very popular protocol and a library for your programming language will exist.

To learn more about this flow please refer to the specification: https://tools.ietf.org/html/rfc8628
 * @summary The OAuth 2.0 Device Authorize Endpoint
 */
const oAuth2DeviceFlow = (
    
 ) => {
      return hydraMutator<DeviceAuthorization>(
      {url: `/oauth2/device/auth`, method: 'POST'
    },
      );
    }
  
/**
 * This is the device user verification endpoint. The user is redirected here when trying to log in using the device flow.
 * @summary OAuth 2.0 Device Verification Endpoint
 */
const performOAuth2DeviceVerificationFlow = (
    
 ) => {
      return hydraMutator<ErrorOAuth2>(
      {url: `/oauth2/device/verify`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint behaves like the administrative counterpart (`createOAuth2Client`) but is capable of facing the
public internet directly and can be used in self-service. It implements the OpenID Connect
Dynamic Client Registration Protocol. This feature needs to be enabled in the configuration. This endpoint
is disabled by default. It can be enabled by an administrator.

Please note that using this endpoint you are not able to choose the `client_secret` nor the `client_id` as those
values will be server generated when specifying `token_endpoint_auth_method` as `client_secret_basic` or
`client_secret_post`.

The `client_secret` will be returned in the response and you will not be able to retrieve it later on.
Write the secret down and keep it somewhere safe.
 * @summary Register OAuth2 Client using OpenID Dynamic Client Registration
 */
const createOidcDynamicClient = (
    oAuth2Client: OAuth2Client,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/oauth2/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: oAuth2Client
    },
      );
    }
  
/**
 * This endpoint behaves like the administrative counterpart (`deleteOAuth2Client`) but is capable of facing the
public internet directly and can be used in self-service. It implements the OpenID Connect
Dynamic Client Registration Protocol. This feature needs to be enabled in the configuration. This endpoint
is disabled by default. It can be enabled by an administrator.

To use this endpoint, you will need to present the client's authentication credentials. If the OAuth2 Client
uses the Token Endpoint Authentication Method `client_secret_post`, you need to present the client secret in the URL query.
If it uses `client_secret_basic`, present the Client ID and the Client Secret in the Authorization header.

OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 * @summary Delete OAuth 2.0 Client using the OpenID Dynamic Client Registration Management Protocol
 */
const deleteOidcDynamicClient = (
    id: string,
 ) => {
      return hydraMutator<EmptyResponseResponse>(
      {url: `/oauth2/register/${id}`, method: 'DELETE'
    },
      );
    }
  
/**
 * This endpoint behaves like the administrative counterpart (`getOAuth2Client`) but is capable of facing the
public internet directly and can be used in self-service. It implements the OpenID Connect
Dynamic Client Registration Protocol.

To use this endpoint, you will need to present the client's authentication credentials. If the OAuth2 Client
uses the Token Endpoint Authentication Method `client_secret_post`, you need to present the client secret in the URL query.
If it uses `client_secret_basic`, present the Client ID and the Client Secret in the Authorization header.
 * @summary Get OAuth2 Client using OpenID Dynamic Client Registration
 */
const getOidcDynamicClient = (
    id: string,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/oauth2/register/${id}`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint behaves like the administrative counterpart (`setOAuth2Client`) but is capable of facing the
public internet directly to be used by third parties. It implements the OpenID Connect
Dynamic Client Registration Protocol.

This feature is disabled per default. It can be enabled by a system administrator.

If you pass `client_secret` the secret is used, otherwise the existing secret is used. If set, the secret is echoed in the response.
It is not possible to retrieve it later on.

To use this endpoint, you will need to present the client's authentication credentials. If the OAuth2 Client
uses the Token Endpoint Authentication Method `client_secret_post`, you need to present the client secret in the URL query.
If it uses `client_secret_basic`, present the Client ID and the Client Secret in the Authorization header.

OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 * @summary Set OAuth2 Client using OpenID Dynamic Client Registration
 */
const setOidcDynamicClient = (
    id: string,
    oAuth2Client: OAuth2Client,
 ) => {
      return hydraMutator<OAuth2Client>(
      {url: `/oauth2/register/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: oAuth2Client
    },
      );
    }
  
/**
 * Revoking a token (both access and refresh) means that the tokens will be invalid. A revoked access token can no
longer be used to make access requests, and a revoked refresh token can no longer be used to refresh an access token.
Revoking a refresh token also invalidates the access token that was created with it. A token may only be revoked by
the client the token was generated for.
 * @summary Revoke OAuth 2.0 Access or Refresh Token
 */
const revokeOAuth2Token = (
    revokeOAuth2TokenBody: RevokeOAuth2TokenBody,
 ) => {const formUrlEncoded = new URLSearchParams();
if(revokeOAuth2TokenBody.client_id !== undefined) {
 formUrlEncoded.append(`client_id`, revokeOAuth2TokenBody.client_id)
 }
if(revokeOAuth2TokenBody.client_secret !== undefined) {
 formUrlEncoded.append(`client_secret`, revokeOAuth2TokenBody.client_secret)
 }
formUrlEncoded.append(`token`, revokeOAuth2TokenBody.token)

      return hydraMutator<EmptyResponseResponse>(
      {url: `/oauth2/revoke`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded
    },
      );
    }
  
/**
 * This endpoint initiates and completes user logout at the Ory OAuth2 & OpenID provider and initiates OpenID Connect Front- / Back-channel logout:

https://openid.net/specs/openid-connect-frontchannel-1_0.html
https://openid.net/specs/openid-connect-backchannel-1_0.html

Back-channel logout is performed asynchronously and does not affect logout flow.
 * @summary OpenID Connect Front- and Back-channel Enabled Logout
 */
const revokeOidcSession = (
    
 ) => {
      return hydraMutator<unknown>(
      {url: `/oauth2/sessions/logout`, method: 'GET'
    },
      );
    }
  
/**
 * Use open source libraries to perform OAuth 2.0 and OpenID Connect
available for any programming language. You can find a list of libraries here https://oauth.net/code/

This endpoint should not be used via the Ory SDK and is only included for technical reasons.
Instead, use one of the libraries linked above.
 * @summary The OAuth 2.0 Token Endpoint
 */
const oauth2TokenExchange = (
    oauth2TokenExchangeBody: Oauth2TokenExchangeBody,
 ) => {const formUrlEncoded = new URLSearchParams();
if(oauth2TokenExchangeBody.client_id !== undefined) {
 formUrlEncoded.append(`client_id`, oauth2TokenExchangeBody.client_id)
 }
if(oauth2TokenExchangeBody.code !== undefined) {
 formUrlEncoded.append(`code`, oauth2TokenExchangeBody.code)
 }
formUrlEncoded.append(`grant_type`, oauth2TokenExchangeBody.grant_type)
if(oauth2TokenExchangeBody.redirect_uri !== undefined) {
 formUrlEncoded.append(`redirect_uri`, oauth2TokenExchangeBody.redirect_uri)
 }
if(oauth2TokenExchangeBody.refresh_token !== undefined) {
 formUrlEncoded.append(`refresh_token`, oauth2TokenExchangeBody.refresh_token)
 }

      return hydraMutator<OAuth2TokenExchange>(
      {url: `/oauth2/token`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded
    },
      );
    }
  
/**
 * This endpoint returns the payload of the ID Token, including `session.id_token` values, of
the provided OAuth 2.0 Access Token's consent request.

In the case of authentication error, a WWW-Authenticate header might be set in the response
with more information about the error. See [the spec](https://datatracker.ietf.org/doc/html/rfc6750#section-3)
for more details about header format.
 * @summary OpenID Connect Userinfo
 */
const getOidcUserInfo = (
    
 ) => {
      return hydraMutator<OidcUserInfo>(
      {url: `/userinfo`, method: 'GET'
    },
      );
    }
  
/**
 * This endpoint returns the version of Ory Hydra.

If the service supports TLS Edge Termination, this endpoint does not require the
`X-Forwarded-Proto` header to be set.

Be aware that if you are running multiple nodes of this service, the version will never
refer to the cluster state, only to a single instance.
 * @summary Return Running Software Version.
 */
const getVersion = (
    
 ) => {
      return hydraMutator<GetVersion200>(
      {url: `/version`, method: 'GET'
    },
      );
    }
  
return {discoverJsonWebKeys,discoverOidcConfiguration,listOAuth2Clients,createOAuth2Client,deleteOAuth2Client,getOAuth2Client,patchOAuth2Client,setOAuth2Client,setOAuth2ClientLifespans,deleteJsonWebKeySet,getJsonWebKeySet,createJsonWebKeySet,setJsonWebKeySet,deleteJsonWebKey,getJsonWebKey,setJsonWebKey,getOAuth2ConsentRequest,acceptOAuth2ConsentRequest,rejectOAuth2ConsentRequest,acceptUserCodeRequest,getOAuth2LoginRequest,acceptOAuth2LoginRequest,rejectOAuth2LoginRequest,getOAuth2LogoutRequest,acceptOAuth2LogoutRequest,rejectOAuth2LogoutRequest,revokeOAuth2ConsentSessions,listOAuth2ConsentSessions,revokeOAuth2LoginSessions,introspectOAuth2Token,deleteOAuth2Token,listTrustedOAuth2JwtGrantIssuers,trustOAuth2JwtGrantIssuer,deleteTrustedOAuth2JwtGrantIssuer,getTrustedOAuth2JwtGrantIssuer,createVerifiableCredential,isAlive,isReady,oAuth2Authorize,oAuth2DeviceFlow,performOAuth2DeviceVerificationFlow,createOidcDynamicClient,deleteOidcDynamicClient,getOidcDynamicClient,setOidcDynamicClient,revokeOAuth2Token,revokeOidcSession,oauth2TokenExchange,getOidcUserInfo,getVersion}};
export type DiscoverJsonWebKeysResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['discoverJsonWebKeys']>>>
export type DiscoverOidcConfigurationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['discoverOidcConfiguration']>>>
export type ListOAuth2ClientsResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['listOAuth2Clients']>>>
export type CreateOAuth2ClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['createOAuth2Client']>>>
export type DeleteOAuth2ClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['deleteOAuth2Client']>>>
export type GetOAuth2ClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getOAuth2Client']>>>
export type PatchOAuth2ClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['patchOAuth2Client']>>>
export type SetOAuth2ClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['setOAuth2Client']>>>
export type SetOAuth2ClientLifespansResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['setOAuth2ClientLifespans']>>>
export type DeleteJsonWebKeySetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['deleteJsonWebKeySet']>>>
export type GetJsonWebKeySetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getJsonWebKeySet']>>>
export type CreateJsonWebKeySetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['createJsonWebKeySet']>>>
export type SetJsonWebKeySetResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['setJsonWebKeySet']>>>
export type DeleteJsonWebKeyResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['deleteJsonWebKey']>>>
export type GetJsonWebKeyResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getJsonWebKey']>>>
export type SetJsonWebKeyResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['setJsonWebKey']>>>
export type GetOAuth2ConsentRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getOAuth2ConsentRequest']>>>
export type AcceptOAuth2ConsentRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['acceptOAuth2ConsentRequest']>>>
export type RejectOAuth2ConsentRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['rejectOAuth2ConsentRequest']>>>
export type AcceptUserCodeRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['acceptUserCodeRequest']>>>
export type GetOAuth2LoginRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getOAuth2LoginRequest']>>>
export type AcceptOAuth2LoginRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['acceptOAuth2LoginRequest']>>>
export type RejectOAuth2LoginRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['rejectOAuth2LoginRequest']>>>
export type GetOAuth2LogoutRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getOAuth2LogoutRequest']>>>
export type AcceptOAuth2LogoutRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['acceptOAuth2LogoutRequest']>>>
export type RejectOAuth2LogoutRequestResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['rejectOAuth2LogoutRequest']>>>
export type RevokeOAuth2ConsentSessionsResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['revokeOAuth2ConsentSessions']>>>
export type ListOAuth2ConsentSessionsResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['listOAuth2ConsentSessions']>>>
export type RevokeOAuth2LoginSessionsResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['revokeOAuth2LoginSessions']>>>
export type IntrospectOAuth2TokenResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['introspectOAuth2Token']>>>
export type DeleteOAuth2TokenResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['deleteOAuth2Token']>>>
export type ListTrustedOAuth2JwtGrantIssuersResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['listTrustedOAuth2JwtGrantIssuers']>>>
export type TrustOAuth2JwtGrantIssuerResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['trustOAuth2JwtGrantIssuer']>>>
export type DeleteTrustedOAuth2JwtGrantIssuerResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['deleteTrustedOAuth2JwtGrantIssuer']>>>
export type GetTrustedOAuth2JwtGrantIssuerResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getTrustedOAuth2JwtGrantIssuer']>>>
export type CreateVerifiableCredentialResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['createVerifiableCredential']>>>
export type IsAliveResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['isAlive']>>>
export type IsReadyResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['isReady']>>>
export type OAuth2AuthorizeResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['oAuth2Authorize']>>>
export type OAuth2DeviceFlowResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['oAuth2DeviceFlow']>>>
export type PerformOAuth2DeviceVerificationFlowResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['performOAuth2DeviceVerificationFlow']>>>
export type CreateOidcDynamicClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['createOidcDynamicClient']>>>
export type DeleteOidcDynamicClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['deleteOidcDynamicClient']>>>
export type GetOidcDynamicClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getOidcDynamicClient']>>>
export type SetOidcDynamicClientResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['setOidcDynamicClient']>>>
export type RevokeOAuth2TokenResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['revokeOAuth2Token']>>>
export type RevokeOidcSessionResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['revokeOidcSession']>>>
export type Oauth2TokenExchangeResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['oauth2TokenExchange']>>>
export type GetOidcUserInfoResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getOidcUserInfo']>>>
export type GetVersionResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOryHydraAPI>['getVersion']>>>
